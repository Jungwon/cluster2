{"tagline":"node.js cluster","note":"Don't delete this file! It's used internally to help with page regeneration.","body":"## What is cluster2\r\n\r\n![Travis status](https://secure.travis-ci.org/ql-io/cluster2.png)\r\n\r\nNOTE: For node (<=0.6.x), use cluster2 version 0.3.1\r\n\r\ncluster2 is a node.js (>= 0.8.x) compatible multi-process management module. This module grew out of\r\nour needs in operationalizing node.js for [ql.io](https://github.com/ql-io/ql.io) at eBay. Built on\r\nnode's `cluster`, cluster2 adds several safeguards and utility functions to help support real-world\r\nproduction scenarios:\r\n\r\n* Scriptable start, shutdown and stop flows\r\n* Worker monitoring for process deaths\r\n* Worker recycling\r\n* Graceful shutdown\r\n* Idle timeouts\r\n* Validation hooks (for other tools to monitor cluster2 apps)\r\n* Events for logging cluster activities\r\n* Exit with error code when the port is busy to fail start scripts\r\n* Disable monitor\r\n* and more coming soon\r\n\r\n## Usage\r\n\r\n### Getting cluster2\r\n\r\n    npm install cluster2\r\n\r\n### Start a TCP Server\r\n\r\n    var Cluster = require('cluster2'),\r\n        net = require('net');\r\n    var server = net.createServer(function (c) {\r\n        c.on('end', function () {\r\n            console.log('server disconnected');\r\n        });\r\n        c.write('hello\\r\\n');\r\n        c.pipe(c);\r\n    });\r\n\r\n    var c = new Cluster({\r\n        port: 3000,\r\n        cluster: true\r\n    });\r\n\r\n### Start a HTTP Server\r\n\r\n    var Cluster = require('cluster2'),\r\n        http = require('http');\r\n    var server = http.createServer(function (req, res) {\r\n        res.writeHead(200);\r\n        res.end('hello');\r\n    });\r\n    var c = new Cluster({\r\n        port: 3000\r\n    });\r\n    c.listen(function(cb) {\r\n        cb(server);\r\n    });\r\n\r\n### Start an Express Server\r\n\r\n    var Cluster = require('cluster2'),\r\n        express = require('express');\r\n    var app = express.createServer();\r\n    app.get('/', function(req, res) {\r\n        res.send('hello');\r\n    });\r\n\r\n    var c = new Cluster({\r\n        port: 3000,\r\n    });\r\n    c.listen(function(cb) {\r\n        cb(app);\r\n    });\r\n\r\n### Stop a Server\r\n\r\n    var Cluster = require('cluster2');\r\n    var c = new Cluster();\r\n    c.stop();\r\n\r\n### Gracefully Shutdown a Server\r\n\r\n    var Cluster = require('cluster2');\r\n    var c = new Cluster();\r\n    c.shutdown();\r\n\r\n\r\n## Options\r\n\r\nCluster2 takes the following options.\r\n\r\n* `cluster`: When `true` starts a number of workers. Use `false` to start the server as a single\r\n   process. Defaults to `true`.\r\n* `pids`: A directory to write PID files for master and workers.\r\n* `port`: Port number for the app, defaults to `3000`.\r\n* `monPort`: Port number for the monitor URL, defaults to `3001`. Go to `http://<localhost>:3001` to\r\n   view application logs (whatever is written to a `/logs` dir), and npm dependencies.\r\n* `ecv`: ECV stands for \"extended content verification\". This is an object with the following\r\n   additional properties:\r\n     * `path`: A path to serve a heart beat. See below.\r\n     * `monitor`: A URI to check before emitting a valid heart beat signal\r\n     * `control`: When true, allows clients to enable or disable the signal. See below.\r\n     validator to validate the runtime health of the app. If found unhealthy, emits a disable\r\n* `noWorkers`: Defaults to `os.cpus().length`.\r\n* `timeout`: Idle socket timeout. Automatically ends incoming sockets if found idle for this\r\n   duration. Defaults to `30` seconds.\r\n* `connThreshold`: When the number of connections processed exceeds this numbers, recycle the worker\r\n   process. This can help recover from slow leaks in your code or dependent modules.\r\n\r\n## Graceful Shutdown\r\n\r\nThe purpose of `shutdown()` is to let the server reject taking new connections, handle all pending\r\nrequests and end the connecton so that no request dropped. In order to handling `shutdown()`, the\r\nserver must handle `close` events as follows.\r\n\r\n    var serving = true;\r\n    var server = http.createServer(function (req, res) {\r\n        if(!serving) {\r\n            // Be nice and send a connection: close as otherwise the client may pump more requests\r\n            // on the same connection\r\n            res.writeHead(200, {\r\n                'connection': 'close'\r\n            });\r\n        }\r\n        res.writeHead(200);\r\n        res.end('hello');\r\n    });\r\n    server.on('close', function() {\r\n        serving = false;\r\n    })\r\n    var c = new Cluster({\r\n        port: 3000,\r\n        cluster: true\r\n    });\r\n\r\nCompletion of `shutdown()` does not necessarily mean that all worker processes are dead immediately. \r\nThe workers may take a while to complete processing of current requests and exit. The `shutdown()` \r\nflow only guarantees that the server takes no new connections.\r\n\r\n## Cluster2 Events\r\n\r\nCluster2 is an `EventEmitter` and emits the following events.\r\n\r\n* `died`: Emitted when a worker dies. This event is also emitted during normal `shutdown()` or\r\n  `stop()`.\r\n* `forked`: Emitted when a new worker is forked.\r\n* `<signal>`: Emitted when a worker receives a signal (such as `SIGKILL`, `SIGTERM` or `SIGINT`).\r\n\r\nHere is an example that logs these events to the disk.\r\n\r\n    var Cluster = require('cluster2'),\r\n        http = require('http');\r\n\r\n    var server = http.createServer(function (req, res) {\r\n        res.writeHead(200);\r\n        res.end('hello');\r\n    });\r\n    var c = new Cluster({\r\n        cluster: true,\r\n        port: 3000\r\n    });\r\n    c.on('died', function(pid) {\r\n        console.log('Worker ' + pid + ' died');\r\n    });\r\n    c.on('forked', function(pid) {\r\n        console.log('Worker ' + pid + ' forked');\r\n    });\r\n    c.on('SIGKILL', function() {\r\n        console.log('Got SIGKILL');\r\n    });\r\n    c.on('SIGTERM', function(event) {\r\n        console.log('Got SIGTERM - shutting down');\r\n    });\r\n    c.on('SIGINT', function() {\r\n        console.log('Got SIGINT');\r\n    });\r\n    c.listen(function(cb) {\r\n        cb(server);\r\n    });\r\n\r\n## Routing Traffic\r\n\r\nIt is fairly common for proxies or load balancers deployed in front of node clusters, and those\r\nproxies to use monitor URLs to detect the health of the cluster. Cluster2 includes a monitor\r\nat `http://<host>:<port>/ecv`. You can change this by setting the `path` property when initializing\r\nthe cluster.\r\n\r\nIn case you want to take the node cluster out of rotation from the proxy/load balancer, you can do\r\nso by setting `control` to `true` when initializing the cluster. At runtime, you can send a `POST`\r\nrequest to `http://<host>:<port>/ecv/disable`. Once this is done, further requests to\r\n`http://<host>:<port>/ecv` will get a network error. You can bring the cluster back to rotation by\r\nsending a `POST` request to `http://<host>:<port>/ecv/enable`.\r\n\r\nSince it will be potentially disastrous to let artibrary clients enable/disable traffic, you should\r\nconfigure your proxy/load balancer to prevent external traffic to `/ecv*`.\r\n\r\nTo test this, bring up an example\r\n\r\n    node examples/express/express-server.js\r\n\r\nand send a `GET` request to `http://localhost:3000/ecv` and notice the response.\r\n\r\n    HTTP/1.1 200 OK\r\n    X-Powered-By: Cluster2\r\n    content-type: text/plain\r\n    since: Fri May 18 2012 09:49:32 GMT-0700 (PDT)\r\n    cache-control: no-cache\r\n    Connection: keep-alive\r\n    Transfer-Encoding: chunked\r\n\r\n    status=AVAILABLE&ServeTraffic=true&ip=127.0.0.1&hostname=somehost&port=3000&time=Fri May 18 2012 09:49:49 GMT-0700 (PDT)\r\n\r\nTo flip the monitor into a disabled state, send a `POST` request to `http://localhost:3000/disable`.\r\n\r\n    HTTP/1.1 204 No Content\r\n    X-Powered-By: Cluster2\r\n    since: Fri May 18 2012 09:54:25 GMT-0700 (PDT)\r\n    cache-control: no-cache\r\n    Connection: close\r\n\r\nSubsequent `GET` requests to `http://localhost:3000/ecv` will return a response similar to the one\r\nbelow.\r\n\r\n    HTTP/1.1 400 Bad Request\r\n    X-Powered-By: Cluster2\r\n    content-type: text/plain\r\n    since: Fri May 18 2012 09:54:25 GMT-0700 (PDT)\r\n    cache-control: no-cache\r\n    Connection: close\r\n    Transfer-Encoding: chunked\r\n\r\n    status=DISABLED&ServeTraffic=false&ip=127.0.0.1&hostname=somehost&port=3000&time=Fri May 18 2012 09:55:17 GMT-0700 (PDT)\r\n\r\nTo flip the monitor back into an enabled state, send a `POST` request to `http://localhost:3000/enable`.\r\n\r\n","name":"Cluster2","google":""}